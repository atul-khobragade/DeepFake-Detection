# -*- coding: utf-8 -*-
"""MTCNN-DeepFake.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pKKlDJ_IhwfaoEOgf3DD6ZJkpz39VY2w
"""

import pandas as pd
import numpy as np
import PIL
from PIL import Image

import cv2
import os

from matplotlib import pyplot as plt

from google.colab.patches import cv2_imshow

import dlib
from skimage import io
import matplotlib.pyplot as plt
from numpy import asarray

from google.colab import drive
drive.mount('/content/drive')

imgPath=[]
resize= 1
frame_count_real = []
frame_count_fake = []


# Function to extract frames
def FrameCapture(path,globalCount,type_dataset,label):
    frame_count=[]
    imgPath = []
    temp = 0
    v_cap = cv2.VideoCapture(path)
    v_len = int(v_cap.get(cv2.CAP_PROP_FRAME_COUNT))
    
    # Pick 'n_frames' evenly spaced frames to sample
    sample = np.linspace(0, v_len - 1, n_frames).astype(int) #Index in sample array are the frames which will be extracted.

    # Loop through frames
    
    frames = []
    for j in range(v_len):
        success = v_cap.grab()
        if j in sample:
            # Load frame
            success, frame = v_cap.read()
            if not success:
                
                continue
            
            frame = Image.fromarray(frame)
            
            # Resize frame to desired size
            if resize is not None:
                frame = frame.resize([int(d * resize) for d in frame.size])
                frame = np.asarray(frame)
            frames.append(frame)
    
    # Used as counter variable
  
    # checks whether frames were extracted
    count = globalCount
    currentCount = 0
    success = 1
  
    while success and currentCount<min(n_frames,len(frames)):
  

        cv2.imwrite("All_Images/" + str(type_dataset) + "_"+ str(label) + "_frame%d.jpg" % (count//n_frames),frames[int(currentCount)])

        imgPath.append("All_Images/" + str(type_dataset) + "_"+ str(label) + "_frame%d.jpg"%(count//n_frames))
  
        count += n_frames
        currentCount += 1
      
    if(type_dataset=="Test"):
      frame_count.append(currentCount)

    return imgPath,count,frame_count

import os


n_frames = 32
resize= 1

def captureFrame(type_dataset,label):
  imgPath = []
  frame_count = []
  count = 0
  video_label=[]
  for file in os.listdir("/content/drive/MyDrive/Deepfake_Mix/"+str(type_dataset)+"/"+str(label)):
      path=os.path.join("/content/drive/MyDrive/Deepfake_Mix/"+str(type_dataset)+"/"+str(label), file)
      temp , count ,x= FrameCapture(path,count,type_dataset,label)
      imgPath = imgPath +  temp
      if (type_dataset == 'Test'):
        frame_count.append(x[0])
        if label=='Fake':
          video_label.append(0)
        else:
          video_label.append(1)
  return imgPath,frame_count,video_label

imgPath_train_fake,  frame_count_train_fake, _= captureFrame("Train","Fake")
imgPath_train_real,  frame_count_train_real, _= captureFrame("Train","Real")
imgPath_val_fake,  frame_count_val_fake, video_label_val_fake= captureFrame("Val","Fake")
imgPath_val_real,  frame_count_val_real, video_label_val_real= captureFrame("Val","Real")
imgPath_test_fake,  frame_count_test_fake, video_label_test_fake= captureFrame("Test","Fake")
imgPath_test_real,  frame_count_test_real, video_label_test_real= captureFrame("Test","Real")

print(len(imgPath_train_fake))
print(len(imgPath_train_real))
print(imgPath_val_fake)
print(imgPath_val_real)
print(len(imgPath_test_fake))
print(len(imgPath_test_real))

"""#MTCNN"""

pip install mtcnn

from matplotlib import pyplot
from matplotlib.patches import Rectangle
from matplotlib.patches import Circle
from mtcnn.mtcnn import MTCNN
 


# draw each face separately
def draw_faces(filename, result_list,Count,processedImagePath_MTCNN,type_dataset,label):
  # load the image
  data = pyplot.imread(filename)
  # plot each face as a subplot
  count = Count
  processedImagePath_MTCNN=[]
  for i in range(len(result_list)):
   # get coordinates
    x1, y1, width, height = result_list[i]['box']
    x2, y2 = x1 + width, y1 + height
    if x1 < 0:
      x1 = 0
    if y1<0:
      y1=0
    if x2 > data.shape[1]:
      x2 = data.shape[1]
    if y2>data.shape[0]:
      y2=data.shape[0]
    
    resize_face = cv2.resize(data[y1:y2, x1:x2],(64, 64), interpolation=cv2.INTER_CUBIC)
    finalImg = cv2.cvtColor(resize_face, cv2.COLOR_BGR2RGB)
    cv2.imwrite("MTCNN" + "_" + str(type_dataset) + "_" + str(label) + "/mtcnn%d.jpg" % count,finalImg)
    processedImagePath_MTCNN.append("MTCNN" + "_" + str(type_dataset) + "_" + str(label) + "/mtcnn%d.jpg"%count)
    count+=1
  
  return count,processedImagePath_MTCNN
 


def faceDetect_MTCNN(type_dataset,label,imgPath):
  count = 0
  processedImagePath_MTCNN=[]
  for i in range(len(imgPath)):
      filename = imgPath[i]
      # load image from file
      pixels = pyplot.imread(filename)
      # create the detector, using default weights
      detector = MTCNN()
      # detect faces in the image
      faces = detector.detect_faces(pixels)
      count,l=draw_faces(filename, faces,count,processedImagePath_MTCNN,type_dataset,label)
      processedImagePath_MTCNN.append(l)
  return processedImagePath_MTCNN

processedImagePath_Train_Fake_mtcnn = faceDetect_MTCNN("Train","Fake",imgPath_train_fake)

print(len(processedImagePath_Train_Fake_mtcnn))

processedImagePath_Train_Real_mtcnn = faceDetect_MTCNN("Train","Real",imgPath_train_real)

print(len(processedImagePath_Train_Real_mtcnn))

processedImagePath_Test_Fake_mtcnn = faceDetect_MTCNN("Test","Fake",imgPath_test_fake)

print(len(processedImagePath_Test_Fake_mtcnn))

processedImagePath_Test_Real_mtcnn = faceDetect_MTCNN("Test","Real",imgPath_test_real)

print(len(processedImagePath_Test_Real_mtcnn))

"""#Training"""

from sklearn.metrics import accuracy_score
from sklearn.metrics import f1_score
from sklearn.metrics import log_loss
from skimage.color import rgb2grey
from skimage.feature import hog

def create_features(img):
    
    # convert image to greyscale
    
    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
    features=[]
    for i in gray:
      for j in i:
        features.append(j)
    
    return features

def createFeatureDatabase(real_list, fake_list):
  train=[]
  label = []

  

  for i in range(len(fake_list)):
    
    for j in fake_list[i]:
      img = cv2.imread(j)
      tmp_features = create_features(img)
      train.append(tmp_features)
      label.append(0)

  for i in range(len(real_list)):
    for j in real_list[i]:
      img = cv2.imread(j)
      tmp_features = create_features(img)
      train.append(tmp_features)
      label.append(1)

  

  return train,label

train_data,label_data = createFeatureDatabase(processedImagePath_Train_Real_mtcnn,processedImagePath_Train_Fake_mtcnn)

len(train_data)

test_data, test_label = createFeatureDatabase(processedImagePath_Test_Real_mtcnn,processedImagePath_Test_Fake_mtcnn)

"""##Standard Scaler"""

from sklearn.preprocessing import StandardScaler  
scaler = StandardScaler()  
scaler.fit(train_data)  
train_data_ss = scaler.transform(train_data)  
test_data_ss = scaler.transform(test_data)

"""##LDA"""

from sklearn.discriminant_analysis import LinearDiscriminantAnalysis

lda = LinearDiscriminantAnalysis()
lda_train_data = lda.fit_transform(train_data_ss, label_data)

lda_test_data=lda.transform(test_data_ss)

lda.explained_variance_ratio_

lda_train_data

len(lda_train_data[0])

"""##PCA"""

from sklearn.decomposition import PCA
pca = PCA(0.99)
pca_train_data=pca.fit_transform(train_data_ss)

pca_test_data=pca.transform(test_data_ss)

pca.explained_variance_ratio_

pca_train_data

len(pca_train_data[0])

"""#DeepFake Result"""

def predictDeepFakeResult(predicted_test,frame_count_test):
  k=0
  prediction=[]
  len1=len(predicted_test)
  for i in frame_count_test:
    real_count=0
    fake_count=0
    for j in range(i):
      if predicted_test[k]==1:
        real_count+=1
      else:
        fake_count+=1
      k+=1
    if real_count>fake_count:
      prediction.append(1)
    else:
      prediction.append(0)
  return prediction

actual_test_label=video_label_test_fake+video_label_test_real

"""##SVC"""

from sklearn.svm import SVC
from sklearn.model_selection import cross_val_score
def trainSVC(train_data, label_data, test_data,test_label):
  model = SVC()
  model.fit(train_data,label_data)
  print(model.score(test_data,test_label))
  cvs = cross_val_score(model, train_data, label_data, cv=5)
  print(cvs)
  predicted_test = model.predict(test_data)
  return predicted_test, cvs

"""##SVC_LDA"""

predicted_test_SVC_lda, cvs_SVC_lda = trainSVC(lda_train_data,label_data,lda_test_data,test_label)
predicted_test_SVC_lda

print(predicted_test_SVC_lda)

pred_SVC_lda=predictDeepFakeResult(predicted_test_SVC_lda,frame_count_test_fake+frame_count_test_real)
print(pred_SVC_lda)

accuracy_score(actual_test_label, pred_SVC_lda)

f1_score(actual_test_label, pred_SVC_lda)

log_loss(actual_test_label,pred_SVC_lda)

"""##SVC_PCA"""

predicted_test_SVC_pca, cvs_SVC_pca =trainSVC(pca_train_data,label_data,pca_test_data,test_label)
predicted_test_SVC_pca

pred_SVC_pca=predictDeepFakeResult(predicted_test_SVC_pca,frame_count_test_fake+frame_count_test_real)
print(pred_SVC_pca)

accuracy_score(actual_test_label, pred_SVC_pca)

f1_score(actual_test_label, pred_SVC_pca)

log_loss(actual_test_label,pred_SVC_pca)

"""##SVC_Normal"""

predicted_test_SVC_normal, cvs_SVC_normal =trainSVC(train_data,label_data,test_data,test_label)
predicted_test_SVC_normal

pred_SVC_normal=predictDeepFakeResult(predicted_test_SVC_normal,frame_count_test_fake+frame_count_test_real)
print(pred_SVC_normal)

accuracy_score(actual_test_label, pred_SVC_normal)

f1_score(actual_test_label, pred_SVC_normal)

log_loss(actual_test_label,pred_SVC_normal)

"""##Comparison"""

#BoxPlot for cross validation scores

data_SVC = [cvs_SVC_lda, cvs_SVC_pca, cvs_SVC_normal]

fig_SVC = plt.figure(figsize =(10, 7))
  
# Creating axes instance
ax_SVC = fig_SVC.add_axes([0, 0, 1, 1])
  
# Creating plot
bp_SVC = ax_SVC.boxplot(data_SVC)
  
# show plot
plt.show()

"""##MLP"""

from sklearn.neural_network import MLPClassifier
from sklearn.model_selection import cross_val_score

def trainMLP(train_data, label_data, test_data,test_label):
  clf = MLPClassifier()
  clf=clf.fit(train_data,label_data)
  print(clf.score(test_data,test_label))
  cvs = cross_val_score(clf, train_data, label_data, cv=5)
  print(cvs)
  predicted_test = clf.predict(test_data)
  return predicted_test, cvs

"""##MLP_LDA"""

predicted_test_MLP_lda, cvs_MLP_lda =trainMLP(lda_train_data,label_data,lda_test_data,test_label)
predicted_test_MLP_lda

pred_MLP_lda=predictDeepFakeResult(predicted_test_MLP_lda,frame_count_test_fake+frame_count_test_real)
print(pred_MLP_lda)

accuracy_score(actual_test_label, pred_MLP_lda)

f1_score(actual_test_label, pred_MLP_lda)

log_loss(actual_test_label,pred_MLP_lda)

"""##MLP_PCA"""

predicted_test_MLP_pca, cvs_MLP_pca =trainMLP(pca_train_data,label_data,pca_test_data,test_label)
predicted_test_MLP_pca

pred_MLP_pca=predictDeepFakeResult(predicted_test_MLP_pca,frame_count_test_fake+frame_count_test_real)
print(pred_MLP_pca)

accuracy_score(actual_test_label, pred_MLP_pca)

f1_score(actual_test_label, pred_MLP_pca)

log_loss(actual_test_label,pred_MLP_pca)

"""##MLP_Normal"""

predicted_test_MLP_normal, cvs_MLP_normal =trainMLP(train_data,label_data,test_data,test_label)
predicted_test_MLP_normal

pred_MLP_normal=predictDeepFakeResult(predicted_test_MLP_normal,frame_count_test_fake+frame_count_test_real)
print(pred_MLP_normal)

accuracy_score(actual_test_label, pred_MLP_normal)

f1_score(actual_test_label, pred_MLP_normal)

log_loss(actual_test_label,pred_MLP_normal)

"""##Comparison"""

#BoxPlot for cross validation scores

data_MLP = [cvs_MLP_lda, cvs_MLP_pca, cvs_MLP_normal]

fig_MLP = plt.figure(figsize =(10, 7))
  
# Creating axes instance
ax_MLP = fig_MLP.add_axes([0, 0, 1, 1])
  
# Creating plot
bp_MLP = ax_MLP.boxplot(data_MLP)
  
# show plot
plt.show()

"""##KNN"""

from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import cross_val_score
def trainKNN(train_data, label_data, test_data,test_label):
  clf = KNeighborsClassifier(n_neighbors=3)
  clf.fit(train_data,label_data)
  print(clf.score(test_data,test_label))
  cvs = cross_val_score(clf, train_data, label_data, cv=5)
  print(cvs)
  predicted_test = clf.predict(test_data)
  return predicted_test, cvs

"""##KNN_LDA"""

predicted_test_KNN_lda, cvs_KNN_lda =trainKNN(lda_train_data,label_data,lda_test_data,test_label)
predicted_test_KNN_lda

pred_KNN_lda=predictDeepFakeResult(predicted_test_KNN_lda,frame_count_test_fake+frame_count_test_real)
print(pred_KNN_lda)

accuracy_score(actual_test_label, pred_KNN_lda)

f1_score(actual_test_label, pred_KNN_lda)

log_loss(actual_test_label,pred_KNN_lda)

"""##KNN_PCA"""

predicted_test_KNN_pca, cvs_KNN_pca =trainKNN(pca_train_data,label_data,pca_test_data,test_label)
predicted_test_KNN_pca

pred_KNN_pca=predictDeepFakeResult(predicted_test_KNN_pca,frame_count_test_fake+frame_count_test_real)
print(pred_KNN_pca)

accuracy_score(actual_test_label, pred_KNN_pca)

f1_score(actual_test_label, pred_KNN_pca)

log_loss(actual_test_label,pred_KNN_pca)

"""##KNN_Normal"""

predicted_test_KNN_normal, cvs_KNN_normal =trainKNN(train_data,label_data,test_data,test_label)
predicted_test_KNN_normal

pred_KNN_normal=predictDeepFakeResult(predicted_test_KNN_normal,frame_count_test_fake+frame_count_test_real)
print(pred_KNN_normal)

accuracy_score(actual_test_label, pred_KNN_normal)

f1_score(actual_test_label, pred_KNN_normal)

log_loss(actual_test_label,pred_KNN_normal)

"""##Comparison"""

#BoxPlot for cross validation scores

data_KNN = [cvs_KNN_lda, cvs_KNN_pca, cvs_KNN_normal]

fig_KNN = plt.figure(figsize =(10, 7))
  
# Creating axes instance
ax_KNN = fig_KNN.add_axes([0, 0, 1, 1])
  
# Creating plot
bp_KNN = ax_KNN.boxplot(data_KNN)
  
# show plot
plt.show()

"""##Comparison for LDAs"""

#BoxPlot for cross validation scores

data_LDA = [cvs_SVC_lda, cvs_MLP_lda, cvs_KNN_lda]

fig_LDA = plt.figure(figsize =(10, 7))
  
# Creating axes instance
ax_LDA = fig_LDA.add_axes([0, 0, 1, 1])
  
# Creating plot
bp_LDA = ax_LDA.boxplot(data_LDA)
  
# show plot
plt.show()

"""##Comparison for PCAs"""

#BoxPlot for cross validation scores

data_PCA = [cvs_SVC_pca, cvs_MLP_pca, cvs_KNN_pca]

fig_PCA = plt.figure(figsize =(10, 7))
  
# Creating axes instance
ax_PCA = fig_PCA.add_axes([0, 0, 1, 1])
  
# Creating plot
bp_PCA = ax_PCA.boxplot(data_PCA)
  
# show plot
plt.show()

"""##Comparison for Normals"""

#BoxPlot for cross validation scores

data_NORMAL = [cvs_SVC_normal, cvs_MLP_normal, cvs_KNN_normal]

fig_NORMAL = plt.figure(figsize =(10, 7))
  
# Creating axes instance
ax_NORMAL = fig_NORMAL.add_axes([0, 0, 1, 1])
  
# Creating plot
bp_NORMAL = ax_NORMAL.boxplot(data_NORMAL)
  
# show plot
plt.show()